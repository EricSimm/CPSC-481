/*Author: Eric Simmons, Jimmy Lindsey
CPSC481
Moves a turtle bot in a rectangular shape*/

#include <ros/ros.h>
#include <geometry_msgs/Twist.h>
#include <turtlesim/Pose.h>

ros::Publisher velocity_publisher;
turtlesim::Pose turtlesim_pose;
const double PI = 3.1415926535897;

//move forward/backward a set distance. distance calculated based off calculated speed * time
//speed = how fast we move, distance = how far, isForward set to true or false to move forward or backward
void move(double speed, double distance, bool isForward);

//turn a desired angle, angle calculations based off speed*time
void rotate(double angular_speed, double angle, bool clockwise);
//used to reorientate to a certain angle based off starting cordinates.
double orientate(double desired_radians);
//converts an angle into radians
double degreestoradians(double angle_in_degrees);
//used for orientate
void poseCallback(const turtlesim::Pose::ConstPtr & pose_message);



int main (int argc, char **argv){

	//initate ROS artifacts
	ros::init(argc, argv, "publish_velocity");
	ros::NodeHandle nh;
	ros::Subscriber pose_sub;
	velocity_publisher = nh.advertise<geometry_msgs::Twist>("turtle1/cmd_vel", 10);
	pose_sub =nh.subscribe("/turtle1/pose",10, poseCallback);
	
	//90* in radians, saves time
	double ninety = degreestoradians(90);


		//rotate in a rectangle
		move(2.0, -3.0, 0);
		rotate(1, ninety, 1);

		move(2.0, 1.5, 1);
		rotate(1, ninety, 1);

		move(2.0, 3.0, 1);
		rotate(1, ninety, 1);

		move(2.0, 1.5, 1);
		rotate(1, ninety, 1);


		orientate(0);

}

//move forward/backward a set distance. distance calculated based off calculated speed * time
//speed = how fast we move, distance = how far, isForward set to true or false to move forward or backward
void move(double speed, double distance, bool isForward)
{
	//initate position/speed/direction
	geometry_msgs::Twist vel_msg;

	if(isForward)
		vel_msg.linear.x=abs(speed);
	else
		vel_msg.linear.x=-abs(speed);

	vel_msg.linear.y = 0;
	vel_msg.linear.z = 0;

	vel_msg.angular.x = 0;
	vel_msg.angular.z = 0;
	vel_msg.angular.y = 0;

	
	double t0 = ros::Time::now().toSec();
	double current_distance = 0;
	ros::Rate loop_rate(10000000);

	//accept negative distance, just move backwards
	if(distance < 0)
	{
		distance = -distance;
		vel_msg.linear.x=-vel_msg.linear.x;
	}

	//loop to we turn our desired distance, calculations based off time/speed
	while(current_distance < distance)
	{
		velocity_publisher.publish(vel_msg);
		double t1 = ros::Time::now().toSec();
		current_distance = speed * (t1-t0);
		ros::spinOnce();
		loop_rate.sleep();
	}

	//stop moving
	vel_msg.linear.x = 0;
	velocity_publisher.publish(vel_msg);

}


//turn a desired angle, angle calculations based off speed*time
void rotate(double angular_speed, double angle, bool clockwise)
{

	//initate position/speed/direction
	geometry_msgs::Twist vel_msg;

	vel_msg.linear.y = 0;
	vel_msg.linear.x = 0;
	vel_msg.linear.z = 0;

	vel_msg.angular.x = 0;
	vel_msg.angular.y = 0;

	if (clockwise)
		vel_msg.angular.z = -abs(angular_speed);
	else
		vel_msg.angular.z = abs(angular_speed);
	//accept negative angle
	if (angle < 0)
	{
		angle = -angle;
		vel_msg.angular.z = -vel_msg.angular.z;
	}

	double current_angle = 0.0;
	ros::Rate loop_rate(10000000);
	double t0 = ros::Time::now().toSec();

	//loop to we turn our desired angle, calculations based off time/speed
	while(current_angle<angle)
	{
		velocity_publisher.publish(vel_msg);
		double t1 = ros::Time::now().toSec();
		current_angle = angular_speed *(t1-t0);
		ros::spinOnce();
		loop_rate.sleep();
	}
	
	//stop moving
	vel_msg.angular.z = 0;
	velocity_publisher.publish(vel_msg);
}

//converts an angle into radians
double degreestoradians(double angle_in_degrees){
	return angle_in_degrees *PI /180.0;
}


//used to reorientate to a certain angle based off starting cordinates.
double orientate(double desired_radians)
{
	double final_radians = desired_radians - turtlesim_pose.theta;
	bool clockwise = ((final_radians <0)?true:false);
	rotate(1, abs(final_radians), clockwise);
	
}

//used for orientate
void poseCallback(const turtlesim::Pose::ConstPtr & pose_message){
	turtlesim_pose.x=pose_message->x;
	turtlesim_pose.y=pose_message->y;
	turtlesim_pose.theta=pose_message->theta;
}

