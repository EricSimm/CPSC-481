// This program can be used to your assignment#3.
// Run this program before your program is started.
#include <ros/ros.h>
#include <turtlesim/Spawn.h>
#include <turtlesim/Kill.h>
#include <turtlesim/Pose.h>
#include <stdlib.h>
#include <math.h>
#include <sstream>
#include <ros/master.h>
#include <boost/algorithm/string.hpp>
#include <geometry_msgs/Twist.h>
#include <algorithm>
//#include "std_msgs/String.h"
#include "std_msgs/Int32MultiArray.h"

using namespace std;

const int MAX_TTURTLES = 3;
const int MAX_XTURTLES = 4;
const double DANGER_TOLERANCE = 0.5;
const double LOWER_LIMIT = 0.0;
const double UPPER_LIMIT = 11.0;
const double PI = 3.14159265;

struct TurtlePose {
  string turtlename;
  string topicname;
  turtlesim::Pose pose;
};

///////////////////////////////
namespace HW {
  static TurtlePose turtle1;
  static TurtlePose tturtles[MAX_TTURTLES];
  static TurtlePose xturtles[MAX_XTURTLES];
  static ros::ServiceClient sClient;
  static ros::ServiceClient kClient;
  static string getTurtlename(const string topicname);
  static bool topicExist(const string topicname);
  static bool turtleExist(const string turtlename);
  static turtlesim::Pose getNonOverlappingPoint(char tType);
  static void createTurtles(char tType, int cnt);
  static double getDistance(double x1, double y1, double x2, double y2);
  static bool isTooClose(double x1, double y1, double x2, double y2, double threshhold);
  static void removeTurtle1();
  static void removeTurtle();
  static void capture();
  static double getTan(const TurtlePose turtle1, const TurtlePose tturtle);
  static double getConstant(const TurtlePose turtle1, const double k); //k is tan
  static double getRadiansToTarget(const TurtlePose turtle1, const TurtlePose tturtle);
  static double degrees2radians(double angle_in_degrees);
  static double getVillan2Path(const TurtlePose xturtle, const TurtlePose turtle1, const TurtlePose tturtle);
  static bool villanInScope(const TurtlePose xturtle, const TurtlePose turtle1, const TurtlePose tturtle);
  //void rotate(double angular_speed, double relative_angle, bool clockwise);
  //void setDesiredOrientation(double desired_angle_radians) ;
  //static void move(double speed, double distance, bool isForward);
  void poseCallback(const turtlesim::Pose::ConstPtr & pose_message);
  void initTurtle1();
};



namespace HW {

  void initTurtle1() {
    turtlesim::Kill::Request reqk;
    turtlesim::Kill::Response respk;

    reqk.name = HW::turtle1.turtlename;
    if (!HW::kClient.call(reqk, respk))
       ROS_ERROR_STREAM("Error: Failed to kill " << reqk.name.c_str() << "\n");
    else
       ROS_INFO_STREAM("move to start point");

    turtlesim::Spawn::Request req;
    turtlesim::Spawn::Response resp;
    req.name = "turtle1";
    req.x = 0;
    req.y = 0;
    req.theta = 0;
    HW::turtle1.turtlename = "turtle1";
    HW::turtle1.topicname ="turtle1";
    HW::turtle1.pose.x = 0;
    HW::turtle1.pose.y = 0;
    HW::turtle1.pose.theta = 0;

    HW::sClient.call(req, resp);
    //ROS_INFO_STREAM("...shutting down...\n");
    //ros::shutdown();
  }

  void poseCallback(const turtlesim::Pose::ConstPtr & pose_message){
    turtle1.pose.x = pose_message->x;
    turtle1.pose.y = pose_message->y;
    turtle1.pose.theta = pose_message->theta;
  }

  bool villanInScope(const TurtlePose xturtle, const TurtlePose turtle1, const TurtlePose tturtle){
      int max_x = max(turtle1.pose.x, tturtle.pose.x);
      int min_x = max(turtle1.pose.x, tturtle.pose.x);
      int max_y = max(turtle1.pose.y, tturtle.pose.y);
      int min_y = max(turtle1.pose.y, tturtle.pose.y);
      if(xturtle.pose.x > min_x && xturtle.pose.x < max_x && xturtle.pose.y > min_y && xturtle.pose.y < max_y){
        return true;
      }
      return false;
  }

  double getVillan2Path(const TurtlePose xturtle, const TurtlePose turtle1, const TurtlePose tturtle){
    double dist2Path = 12;
    //if(villanInScope(xturtle, turtle1, tturtle)){
      double k = getTan(turtle1, tturtle);
      double constant = getConstant(turtle1, k);
      dist2Path = (k*xturtle.pose.x-xturtle.pose.y+constant)/sqrt(pow(k,2) + 1);
    //} // kx-y+constant = 0
    return dist2Path;
  }

  double getTan(const TurtlePose turtle1, const TurtlePose tturtle){
    return (tturtle.pose.y-turtle1.pose.y)/(tturtle.pose.x-turtle1.pose.x);
  }

  double getConstant(const TurtlePose turtle1, const double k){
      double c = turtle1.pose.y-k*turtle1.pose.x;
      return c;
  }


  double getRadiansToTarget(const TurtlePose turtle1, const TurtlePose tturtle){
    return degrees2radians(atan2((tturtle.pose.y-turtle1.pose.y),(tturtle.pose.x-turtle1.pose.x)));
  }

  double degrees2radians(double angle_in_degrees){
    return angle_in_degrees*PI/180.0;
  }

string getTurtlename(const string topicname) {
  vector<string> elems;
  char lc_delim[2];
  lc_delim[0] = '/';
  lc_delim[1] = '\0';

  boost::algorithm::split(elems, topicname, boost::algorithm::is_any_of(lc_delim));
  return elems[1];
}

bool topicExist(const string topicname) {
  int i;
  string tname;
  ros::master::V_TopicInfo alltopics;

  //get all topic names
  ros::master::getTopics(alltopics);

  for (int i=0; i<alltopics.size(); i++) {
     tname = alltopics[i].name;
     if (tname.compare(topicname) == 0) {
        return true;
     };
  };
  return false;
}

bool turtleExist(const string turtlename) {
  int i;
  string tname;
  ros::master::V_TopicInfo alltopics;

  //get all topic names
  ros::master::getTopics(alltopics);

  for (int i=0; i<alltopics.size(); i++) {
     tname = getTurtlename(alltopics[i].name);
     if (tname.compare(turtlename) == 0) {
        return true;
     };
  };
  return false;
}

turtlesim::Pose getNonOverlappingPoint(char tType) {
  turtlesim::Pose xp;
  bool tooclose = false;
  int i;
  int ocnt=0;

  xp.x = double((rand() % 10) + 2.0);
  xp.y = double((rand() % 10) + 2.0);

  while (true) {
    if (HW::isTooClose(HW::turtle1.pose.x, HW::turtle1.pose.y, xp.x, xp.y, DANGER_TOLERANCE))
        tooclose = true;
    else if (tType == 'T')
            break; //out of while loop
    else { //X turtle needs to check all T turtles
       for (i=0; i<MAX_TTURTLES; i++) {
           if (HW::isTooClose(HW::tturtles[i].pose.x, HW::tturtles[i].pose.y, xp.x, xp.y, DANGER_TOLERANCE)) {
              tooclose = true;
              break; //out of for loop and regenerate a point
           };
       };
    };

    if (!tooclose) //checking for X turtle case
       break; //out of while loop

    if (ocnt>1000) { //only to check abnormality
       ROS_INFO_STREAM("chk: " << xp.x << "," << xp.y << "\n");
       break; //possibly wrong so exit
    };
    //generate another random pose
    xp.x = double((rand() % 10) + 2.0);
    xp.y = double((rand() % 10) + 2.0);
    tooclose = false;
    ocnt++;
    ROS_INFO_STREAM(".");
  };
  return xp;
}

void createTurtles(char tType, int cnt) {
  int i;
  stringstream tname, cmdstr;
  bool success = false;
  turtlesim::Spawn::Request req;
  turtlesim::Spawn::Response resp;
  turtlesim::Pose nop;

  /*int tXVal[3] = {8, 6, 7};
  int tYVal[3] = {3, 6, 9};
  int xXVal[4] = {9, 5, 8, 10};
  int xYVal[4] = {2, 5, 8, 4};*/
  

  //removeTurtle1();
  for (i=0; i<cnt; i++) {
     tname.clear();
     tname.str("");
     tname << tType << i + 1;
     req.name = tname.str();
     nop = HW::getNonOverlappingPoint(tType);
     req.x = nop.x;
     req.y = nop.y;
     /*
     if(tType == 'T')
     {
	req.x = tXVal[i];
	req.y = tYVal[i];
     }
     else
     {
	req.x = xXVal[i];
	req.y = xYVal[i];
     }*/
     req.theta = M_PI/2; //face up for target turtles

     tname.clear();
     tname.str("");
     tname << "/" << req.name << "/pose";



     //fill out turtles tables for pose tracking
     if (tType == 'X') {
        req.theta = 3.0*req.theta; //change to face down for villain turtles
        HW::xturtles[i].turtlename = req.name;
        HW::xturtles[i].topicname = tname.str();
        HW::xturtles[i].pose.x = req.x;
        HW::xturtles[i].pose.y = req.y;
        HW::xturtles[i].pose.theta = req.theta;
     }
     else {
        HW::tturtles[i].turtlename = req.name;
        HW::tturtles[i].topicname = tname.str();
        HW::tturtles[i].pose.x = req.x;
        HW::tturtles[i].pose.y = req.y;
        HW::tturtles[i].pose.theta = req.theta;
     };

     //if this turtle does not exist, create one else teleport it.
     if (!turtleExist(req.name.c_str())) {
        success = HW::sClient.call(req, resp);
        if(success) {
           if (tType == 'X')
              ROS_INFO("%s landed with face down.", req.name.c_str()); //X turtle
           else
              ROS_INFO("%s landed with face up.", req.name.c_str()); //T turtle
        }
        else {
          ROS_ERROR_STREAM("Error: Failed to create " << tType << " turtle.");
          ros::shutdown();
        }
     }
     else {
        cmdstr.clear();
        cmdstr.str("");
        cmdstr << "rosservice call /";
        cmdstr << req.name.c_str() << "/teleport_absolute " << req.x << " " << req.y << " " << req.theta;
        system(cmdstr.str().c_str());
        ROS_INFO_STREAM(req.name.c_str() << " already landed, so it's teleported!\n");
     };
  };
}

double getDistance(const double x1, const double y1, const double x2, const double y2) {
  return sqrt(pow((x1-x2),2) + pow(y1-y2, 2));
}

bool isTooClose(double x1, double y1, double x2, double y2, double threshhold) {
  if (HW::getDistance(x1, y1, x2, y2) <= threshhold)
     return true;
  else
     return false;
}

void removeTurtle1() {
  turtlesim::Kill::Request reqk;
  turtlesim::Kill::Response respk;

  reqk.name = HW::turtle1.turtlename;
  if (!HW::kClient.call(reqk, respk))
     ROS_ERROR_STREAM("Error: Failed to kill " << reqk.name.c_str() << "\n");
  else
     ROS_INFO_STREAM("!!! Mission failed !!!");

  ROS_INFO_STREAM("...shutting down...\n");
  ros::shutdown();
}

void removeTurtle(string turtlename){
  turtlesim::Kill::Request reqk;
  turtlesim::Kill::Response respk;

  reqk.name = turtlename;
  if (!HW::kClient.call(reqk, respk))
     ROS_ERROR_STREAM("Error: Failed to kill " << reqk.name.c_str() << "\n");
  else
     ROS_INFO_STREAM("Killed: " << reqk.name.c_str() << "\n");

  ROS_INFO_STREAM("...shutting down...\n");
  ros::shutdown();
}

}; //end of namespace
///////////////////////////////////////

class Turtle1Listener {
  public:
    void doTest(const turtlesim::Pose::ConstPtr& msg);
  private:
    bool isOffBoundary();
    bool isTooClose();
};

//turtle1 callback
void Turtle1Listener::doTest(const turtlesim::Pose::ConstPtr& msg) {
  //update turtle1 pose whenever turtle1 moves
  HW::turtle1.pose.x = msg->x;
  HW::turtle1.pose.y = msg->y;

  //test case1
  if (isOffBoundary())
     HW::removeTurtle1();

  //test case2
  if (isTooClose())
     HW::removeTurtle1();
};

bool Turtle1Listener::isOffBoundary() {
  if (HW::turtle1.pose.x < LOWER_LIMIT || HW::turtle1.pose.x > UPPER_LIMIT || HW::turtle1.pose.y < LOWER_LIMIT || HW::turtle1.pose.y > UPPER_LIMIT) {
     ROS_INFO_STREAM("turtle1 is moving off the limit at (" << HW::turtle1.pose.x << "," << HW::turtle1.pose.y << ")");
     return true;
  } else
     return false;
}

bool Turtle1Listener::isTooClose() {
  int i;
  bool tooclose = false;
  double dist;

  //when turtle1 moves, check all X turtles' locations
  for (i=0; i<MAX_XTURTLES; i++) {
     dist = HW::getDistance(HW::turtle1.pose.x, HW::turtle1.pose.y, HW::xturtles[i].pose.x, HW::xturtles[i].pose.y);
     if (dist <= DANGER_TOLERANCE) {
        tooclose = true;
        ROS_INFO_STREAM("Turtle1 was too close to " << HW::xturtles[i].turtlename << " with distance = " << dist);
        // Captured
        ROS_INFO_STREAM("turtle1 was captured.");
        break;
     };
  };
  return tooclose;
}

class XTurtleListener {
  public:
    void doTest(const turtlesim::Pose::ConstPtr& msg, const string turtlename);
  private:
    bool isTooClose(int ti);
};

//xturtle callback
void XTurtleListener::doTest(const turtlesim::Pose::ConstPtr& msg, const string turtlename) {
  int turtleIdx;
  //update a xturtle pose whenever xturtle moves
  turtleIdx = atoi(turtlename.substr(1).c_str()); //extract turtle # from turtlename
  turtleIdx = turtleIdx - 1; //since index starts from 0
  HW::xturtles[turtleIdx].pose.x = msg->x;
  HW::xturtles[turtleIdx].pose.y = msg->y;

  if (isTooClose(turtleIdx)) {
     HW::removeTurtle1();
  };
};

//when a xturtle moves, check the turtle1's location
bool XTurtleListener::isTooClose(int ti) {
  double dist;
  bool tooclose = false;

  dist = HW::getDistance(HW::xturtles[ti].pose.x, HW::xturtles[ti].pose.y, HW::turtle1.pose.x, HW::turtle1.pose.y);
  if (dist <= DANGER_TOLERANCE) {
     tooclose = true;
     ROS_INFO_STREAM("Turtle1 was too close to " << HW::xturtles[ti].turtlename << " with distance = " << dist);
     ROS_INFO_STREAM("turtle1 was captured.");
  };
  return tooclose;
}

class TTurtleListener {
  public:
    void doTest(const turtlesim::Pose::ConstPtr& msg, const string turtlename);
  private:
    bool isTooClose(int ti);
};

//xturtle callback
void TTurtleListener::doTest(const turtlesim::Pose::ConstPtr& msg, const string turtlename) {
  int turtleIdx;
  //update a xturtle pose whenever xturtle moves
  turtleIdx = atoi(turtlename.substr(1).c_str()); //extract turtle # from turtlename
  turtleIdx = turtleIdx - 1; //since index starts from 0
  HW::tturtles[turtleIdx].pose.x = msg->x;
  HW::tturtles[turtleIdx].pose.y = msg->y;

  if (isTooClose(turtleIdx)) {
     HW::removeTurtle1();

  };
};

//when a xturtle moves, check the turtle1's location
bool TTurtleListener::isTooClose(int ti) {
  double dist;
  bool tooclose = false;

  dist = HW::getDistance(HW::tturtles[ti].pose.x, HW::tturtles[ti].pose.y, HW::turtle1.pose.x, HW::turtle1.pose.y);
  if (dist <= DANGER_TOLERANCE) {
     tooclose = true;
     ROS_INFO_STREAM("Turtle1 was too close to " << HW::tturtles[ti].turtlename << " with distance = " << dist);
     ROS_INFO_STREAM(HW::tturtles[ti].turtlename << " was captured.");
  };
  return tooclose;
}



class HWTest {
  public:
    HWTest(ros::NodeHandle* anh) {
      _nh = *anh;
    };

    void init();
    void startTest();

  private:
    ros::NodeHandle _nh;
    ros::Publisher _turtle1pub;
    ros::Subscriber _turtle1sub;
    // publisher
    ros::Publisher _xturtlepubs[MAX_XTURTLES];
    ros::Publisher _tturtlepubs[MAX_TTURTLES];
    // Subscriber
    ros::Subscriber _xturtlesubs[MAX_XTURTLES];
    ros::Subscriber _tturtlesubs[MAX_TTURTLES];
    Turtle1Listener _turtle1listener;
    XTurtleListener _xturtlelisteners[MAX_XTURTLES];
    TTurtleListener _tturtlelisteners[MAX_TTURTLES];
    //MYHW myhwtest;
};

void HWTest::init() {
  int i;
  stringstream cmdstr;

  HW::sClient = _nh.serviceClient<turtlesim::Spawn>("spawn");
  HW::kClient = _nh.serviceClient<turtlesim::Kill>("kill");

  //set seed for random number
  srand(time(0));

  HW::turtle1.turtlename = "turtle1";
  HW::turtle1.topicname = "/turtle1/pose";


  //create T turtles before X turtles to avoid landing xturtle on the same location
  HW::createTurtles('T', MAX_TTURTLES);
  HW::createTurtles('X', MAX_XTURTLES);
  HW::initTurtle1();



  //create turtle1 publisher && subsriber
  //_turtle1pub = n.advertise<geometry_msgs::Twist>("/turtle1/cmd_vel", 1000);
  _turtle1sub = _nh.subscribe<turtlesim::Pose>(HW::turtle1.topicname, 1000, &Turtle1Listener::doTest, &_turtle1listener);
  //create xturtle subsribers
  for (i=0; i<MAX_XTURTLES; i++) {
     _xturtlesubs[i] = _nh.subscribe<turtlesim::Pose>(HW::xturtles[i].topicname, 1000, boost::bind(&XTurtleListener::doTest, &_xturtlelisteners[i], _1, HW::xturtles[i].turtlename));
  };

  for (i=0; i<MAX_TTURTLES; i++) {
     _tturtlesubs[i] = _nh.subscribe<turtlesim::Pose>(HW::tturtles[i].topicname, 1000, boost::bind(&TTurtleListener::doTest, &_tturtlelisteners[i], _1, HW::tturtles[i].turtlename));
     double dist = HW::getDistance(HW::turtle1.pose.x, HW::turtle1.pose.y, HW::tturtles[i].pose.x , HW::tturtles[i].pose.y);
     ROS_INFO_STREAM("turtle1 to target turtle " << i << " dist is " << dist);
     double radians = HW::getRadiansToTarget(HW::turtle1, HW::tturtles[i]);
     ROS_INFO_STREAM("turtle1 to target turtle " << i << " radians is " << radians);
  };

  for (int i=0; i<MAX_XTURTLES; i++) {
    for (int j=0; j<MAX_TTURTLES; j++){
      double dist2Path = HW::getVillan2Path(HW::xturtles[i],HW::turtle1,HW::tturtles[j]);
      ROS_INFO_STREAM("xturtle" << i <<  " to Path turtle1 to tturtle " << j << " dist is " << dist2Path);
    }
  }

}

void HWTest::startTest() {
  ROS_INFO_STREAM("---------------- Ready to Test ----------------");
  ROS_INFO_STREAM("1. turtle1 will be removed if it moves off the limit (" << LOWER_LIMIT << "," << LOWER_LIMIT << ") and (" << UPPER_LIMIT << "," << UPPER_LIMIT << ")");
  ROS_INFO_STREAM("2. turtle1 can capture T turtle within the distance " << DANGER_TOLERANCE);
  ROS_INFO_STREAM("3. X turtle will capture turtle1 within the distance " << DANGER_TOLERANCE);
  ROS_INFO_STREAM("-----------------------------------------------");

  ros::spin();
}


ros::Publisher velocity_publisher;
ros::Subscriber pose_subscriber;
turtlesim::Pose turtlesim_pose;


void move(double speed, double distance, bool isForward);
void rotate(double angular_speed, double angle, bool clockwise);
double degreestoradians(double angle_in_degrees);
double getDistance(double x1, double y1, double x2, double y2);
double getDistance(TurtlePose t1, TurtlePose t2);
double getDistance(double x1, double y1, TurtlePose t2);
void checkPos(double& x, double& y, int count);
bool moveGoal(turtlesim::Pose goal_pose, double distance_tolerance);
void poseCallback(const turtlesim::Pose::ConstPtr & pose_message);



//this moves the turtle a set distance
void move(double speed, double distance, bool isForward)
{
	geometry_msgs::Twist vel_msg;

	if(isForward)
		vel_msg.linear.x=abs(speed);
	else
		vel_msg.linear.x=-abs(speed);

	vel_msg.linear.y = 0;
	vel_msg.linear.z = 0;

	vel_msg.angular.x = 0;
	vel_msg.angular.z = 0;
	vel_msg.angular.y = 0;

	double t0 = ros::Time::now().toSec();
	double current_distance = 0;
	ros::Rate loop_rate(10000);

	do
	{
		velocity_publisher.publish(vel_msg);
		double t1 = ros::Time::now().toSec();
		current_distance = speed * (t1-t0);
		ros::spinOnce();
		loop_rate.sleep();
	}
	while(current_distance < distance);

	vel_msg.linear.x = 0;
	velocity_publisher.publish(vel_msg);

}

//turn a desired angle, angle calculations based off speed*time
void rotate(double angular_speed, double angle, bool clockwise)
{

	//initate position/speed/direction
	geometry_msgs::Twist vel_msg;

	vel_msg.linear.y = 0;
	vel_msg.linear.x = 0;
	vel_msg.linear.z = 0;

	vel_msg.angular.x = 0;
	vel_msg.angular.y = 0;

	if (clockwise)
		vel_msg.angular.z = -abs(angular_speed);
	else
		vel_msg.angular.z = abs(angular_speed);
	//accept negative angle
	if (angle < 0)
	{
		angle = -angle;
		vel_msg.angular.z = -vel_msg.angular.z;
	}

	double current_angle = 0.0;
	ros::Rate loop_rate(10000000);
	double t0 = ros::Time::now().toSec();

	//loop to we turn our desired angle, calculations based off time/speed
	while(current_angle<angle)
	{
		velocity_publisher.publish(vel_msg);
		double t1 = ros::Time::now().toSec();
		current_angle = angular_speed *(t1-t0);
		ros::spinOnce();
		loop_rate.sleep();
	}

	//stop moving
	vel_msg.angular.z = 0;
	velocity_publisher.publish(vel_msg);
}


//converts degrees to radians
double degreestoradians(double angle_in_degrees){
	return angle_in_degrees *PI /180.0;
}

//these get the distance between two points
double getDistance(double x1, double y1, double x2, double y2)
{
	return sqrt(pow((x1-x2),2)+pow((y1-y2),2));
}

double getDistance(TurtlePose t1, TurtlePose t2)
{
	return sqrt(pow((t1.pose.x-t2.pose.x),2)+pow((t1.pose.y-t2.pose.y),2));
}

double getDistance(double x1, double y1, TurtlePose t2)
{
	return sqrt(pow((x1-t2.pose.x),2)+pow((y1-t2.pose.y),2));
}


//finds the future x and y values based on our orientation
void checkPos(double& x, double& y, int count)
{

	y = .3*sin(turtlesim_pose.theta + (0.0872665 * count)) + turtlesim_pose.y;
	x = .3*cos(turtlesim_pose.theta + (0.0872665 * count)) + turtlesim_pose.x;

}

//finds the shortest distance to all villain
double villainDist(double x, double y)
{
  double distX1 = getDistance(x, y, HW::xturtles[0]);
  double distX2 = getDistance(x, y, HW::xturtles[1]);
  double distX3 = getDistance(x, y, HW::xturtles[2]);
  double distX4 = getDistance(x, y, HW::xturtles[3]);

  double m1 = min(distX1, distX2);
  double m2 = min(distX3, distX4);
  return min(m1, m2);
}

//moves turtle1 towards the goal_pose within the distance tolerance
//also, avoids villain turtles and the borders
bool moveGoal(turtlesim::Pose goal_pose, double distance_tolerance)
{
	geometry_msgs::Twist vel_msg;

	ros::Rate loop_rate(400);

	do{
		//double Kp = 1.0;
		//double Ki = 0.02;

		double x = turtlesim_pose.x;
		double y = turtlesim_pose.y;
		//predict where we will move in the next step
		checkPos(x, y, 0);
		
		//see how close future position is to the closest villain
		double distV = villainDist(x, y);
		//check to see if we have been captured
		if (villainDist(turtlesim_pose.x, turtlesim_pose.y) <= .5)
		{
			cout << "Too close to villain, captured" << endl;
			return false;
		}
		//check all villain turtles and border
		//move away if we are going to hit them
		if(distV <= 0.5 ||x > 11 || y > 11 || x < 0 || y < 0)
		{
			vel_msg.linear.x = 0;
			vel_msg.angular.z = 0;
			velocity_publisher.publish(vel_msg);
			double futureX, futureY;
			int factorToTurn = 9;
			while(1){

				checkPos(futureX, futureY, factorToTurn);

				if (futureX < 11 && futureY < 11 && futureX > 0 && futureY > 0 && villainDist(futureX,futureY) > 0.5)
					break;
				factorToTurn += 9;
			}
			rotate(4, 0.0872665*factorToTurn, true);
			move(1, 0.3, true);
		}
		//continue on if we don't need to avoid anything
		if(distV > .5)
		{
			vel_msg.linear.x = 1;
			vel_msg.linear.y = 0;
			vel_msg.linear.z = 0;

			vel_msg.angular.x = 0;
			vel_msg.angular.y = 0;
			vel_msg.angular.z = 6*(atan2(goal_pose.y-turtlesim_pose.y, goal_pose.x-turtlesim_pose.x)-turtlesim_pose.theta);
		}
		//currently not used, but we afraid to delete it
		else
		{

			vel_msg.linear.x = 0;
			vel_msg.angular.z = 0;
			velocity_publisher.publish(vel_msg);

			double x = 0.0;
			double y = 0.0;
			int count = 1;
			bool isNeg = false;
			while(distV <= .5 || x > 11 || y > 11 || x < 0 || y < 0)
			{
				isNeg = false;
				checkPos(x,y, count);
				distV = villainDist(x, y);

				if(distV > .5 && x < 11 && y < 11 && x > 0 && y > 0)
					break;
				isNeg = true;
				checkPos(x, y, -count);
				distV = villainDist(x, y);
				count++;
			}
			vel_msg.linear.x = 1;
			vel_msg.linear.y = 0;
			vel_msg.linear.z = 0;

			vel_msg.angular.x = 0;
			vel_msg.angular.y = 0;
			double theta = 0.0;
			if(isNeg)
				theta = turtlesim_pose.theta + (0.0872665 * -count);
			else
				theta = turtlesim_pose.theta + (0.0872665 * count);
			vel_msg.angular.z = 6*(atan2(y-turtlesim_pose.y, x-turtlesim_pose.x)-theta);
			/*double theta = 0.0;
			if(isNeg)
				theta = turtlesim_pose.theta + (0.174533 * -count);
			else
				theta = turtlesim_pose.theta + (0.174533 * count);
			rotate(4, theta, 1);
			move(4, 0.45, true);*/

		}

		velocity_publisher.publish(vel_msg);

		ros::spinOnce();
		loop_rate.sleep();
	}while(getDistance(turtlesim_pose.x, turtlesim_pose.y, goal_pose.x, goal_pose.y)>distance_tolerance);

	
	vel_msg.linear.x = 0;
	vel_msg.angular.z = 0;
	velocity_publisher.publish(vel_msg);
	return true;
}


void poseCallback(const turtlesim::Pose::ConstPtr & pose_message){
	turtlesim_pose.x=pose_message->x;
	turtlesim_pose.y=pose_message->y;
	turtlesim_pose.theta=pose_message->theta;
}

int main(int argc, char **argv) {
  ros::init(argc, argv, "HWTest");
  ros::NodeHandle nh;
  ros::Rate loopRate(2);

  HWTest hw3t(&nh);
  hw3t.init();
  ROS_INFO_STREAM("START TO PUBLISH");

  ros::Subscriber pose_sub;
  velocity_publisher = nh.advertise<geometry_msgs::Twist>("turtle1/cmd_vel", 10);
  ROS_INFO_STREAM("Past 3");
  pose_subscriber = nh.subscribe("/turtle1/pose", 10, poseCallback);


  TurtlePose pose;
  std::vector<TurtlePose> targets;
  for(int i = 0; i < 3; i++)
  {
    targets.push_back(HW::tturtles[i]);
  }
  pose.pose.y = 11;
	pose.pose.x = 11;
	pose.pose.theta=0;
  double min = 100;
  int index = 0;

	double t0 = ros::Time::now().toSec();

  int capT = 0;
  bool capturedT = true;
  for(int j=0; j < MAX_TTURTLES; j++){
  // find the minimal distance from turtle1 to all the target turtles.
    for(int i = 0; i < targets.size(); i++)
    {
      double dist = getDistance(turtlesim_pose.x,turtlesim_pose.y, targets[i]);
      if(dist < min)
      {
        pose = targets[i];
        min = dist;
        index = i;
      }
    }
    //go after the closest turtle
    cout << "going after " << pose.turtlename << " at: " << pose.pose.x << ", " << pose.pose.y << endl;
    //remove the turtle we are looking for, as we dont want to try to find it again
    targets.erase(targets.begin() + index);
    
    capturedT = moveGoal(pose.pose, 0.5);
    //we look to see if our turtle has been captured. If it hasn't, we have reached a target turtle and we kill it
    if(capturedT)
    {
    	turtlesim::Kill::Request reqk;
    	turtlesim::Kill::Response respk;
    	reqk.name = pose.turtlename;
    	capT++;
    	if (!HW::kClient.call(reqk, respk))
       		ROS_ERROR_STREAM("Error: Failed to kill " << reqk.name.c_str() << "\n");
    	else
    	   	ROS_INFO_STREAM("turtle captured");
    	min = 100;
    }
    else
	break;
  }


	//ros::Rate loop_rate(100000);

	double t1 = ros::Time::now().toSec();
	cout << "Distance = time * velocity (1) = " << t1-t0 << endl;
	cout << "Number of target turtles captured: " << capT << endl;

  ROS_INFO_STREAM("Finished");

  //========================= end of calling moveGoal========================





  return 0;
}
